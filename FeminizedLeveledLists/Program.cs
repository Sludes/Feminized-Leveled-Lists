using System;
using System.Collections.Generic;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Threading.Tasks;
using Mutagen.Bethesda.Plugins;

namespace FeminizedLeveledLists
{
    public class Program
    {
        static Lazy<PatcherConfig> configOptions = null!;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(nickname: "Mod Settings", path: "patchSettings.json", out configOptions)
                .SetTypicalOpen(GameRelease.SkyrimSE, "FeminineLvlLists.esp")
                .Run(args);
        }

        public static bool ReplaceLeveledNPCList(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, string? replacementName, LeveledNpc? leveledNpc)
        {
            if (leveledNpc is null)
                return false;

            ILeveledNpcGetter[]? replacementList = state.LoadOrder.PriorityOrder.LeveledNpc().WinningOverrides().Where(x => x.EditorID == replacementName).ToArray();
            if(replacementList.Length > 0)
            {
                leveledNpc.Entries = replacementList.First().DeepCopy().Entries;
                return true;
            }

            return false;
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            foreach (ILeveledNpcGetter? lvlngetter in state.LoadOrder.PriorityOrder.LeveledNpc().WinningOverrides())
            {
                bool wasModified = false;
                string? formattedName = null;
                LeveledNpc? lvln = lvlngetter.DeepCopy();

                // Make sure not to replace any lists that might be used for quests.
                if (lvlngetter.EditorID is not null && lvlngetter.EditorID.Contains("VoiceType"))
                    continue;

                // Try to replace the lists on the manual override lists.
                if ( lvlngetter.EditorID is not null && configOptions.Value.ManualOverride is not null && configOptions.Value.ManualOverride.TryGetValue(lvlngetter.EditorID, out string? replacementLvln))
                {
                    lvln.Entries = state.LoadOrder.PriorityOrder.LeveledNpc().WinningOverrides().Where(x => x.EditorID == replacementLvln).First().DeepCopy().Entries;
                    Console.WriteLine("Leveled list " + lvln.EditorID + " was manually overridden by " + replacementLvln + ".");
                    wasModified = true;
                }
                else
                {
                    if (lvln.EditorID is not null)
                    {
                        // Skip entries based on settings.
                        string? editorID = lvln.EditorID.ToLower();
                        if (configOptions.Value.AllowMages && lvln.EditorID is not null && (editorID.Contains("mage") || editorID.Contains("magic") || editorID.Contains("warlock") || editorID.Contains("witch") || editorID.EndsWith("fire") || editorID.EndsWith("ice") || editorID.EndsWith("atro"))) continue;
                        if (configOptions.Value.AllowDraugr && lvln.EditorID is not null && editorID.Contains("draugr")) continue;
                        if (configOptions.Value.AllowFalmer && lvln.EditorID is not null && editorID.Contains("falmer")) continue;
                        if (configOptions.Value.AllowForsworn && lvln.EditorID is not null && editorID.Contains("forsworn")) continue;
                        if (configOptions.Value.AllowVampires && lvln.EditorID is not null && editorID.Contains("vampire")) continue;
                    }

                    // Check for similar leveled lists.
                    if (lvln.EditorID is not null)
                    {
                        // Check leveled lists ending with "M" for an alternative.
                        if (lvln.EditorID.EndsWith("M"))
                        {
                            formattedName = lvln.EditorID.Substring(0, lvln.EditorID.Length - 1) + "F";
                            wasModified = ReplaceLeveledNPCList(state, formattedName, lvln);
                        }
                        // Check leveled lists ending with "Male" for an alternative.
                        else if (lvln.EditorID.EndsWith("Male"))
                        {
                            formattedName = lvln.EditorID.Replace("Male", "Female");
                            wasModified = ReplaceLeveledNPCList(state, formattedName, lvln);

                            if (!wasModified)
                            {
                                formattedName = lvln.EditorID.Replace("Male", "Female");
                                wasModified = ReplaceLeveledNPCList(state, formattedName, lvln);
                            }
                        }
                        // Check leveled lists ending with "MSublist" for an alternative.
                        else if (lvln.EditorID.EndsWith("MSublist"))
                        {
                            formattedName = lvln.EditorID.Replace("MSublist", "FSublist");
                            wasModified = ReplaceLeveledNPCList(state, formattedName, lvln);
                        }
                        // Check leveled lists containing "Male" for an alternative.
                        else if (lvln.EditorID.Contains("Male"))
                        {
                            formattedName = lvln.EditorID.Replace("Male", "Female");
                            wasModified = ReplaceLeveledNPCList(state, formattedName, lvln);
                        }
                    }

                    if (wasModified)
                        Console.WriteLine("Replaced leveled list " + lvln.EditorID + " with " + formattedName + ".");
                }

                // Check if the npc entries are female and replace them if so.
                if (lvln.Entries is not null)
                {
                    int entryCount = lvln.Entries.Count;
                    List<LeveledNpcEntry?> markedForDelete = new List<LeveledNpcEntry?>();

                    // Mark entries for deletion later.
                    foreach (var entry in lvln.Entries)
                    {
                        if (entry.Data is null) continue;
                        if (!entry.Data.Reference.TryResolve<INpcGetter>(state.LinkCache, out var npc) || npc.EditorID is null) continue;
                        if (npc.Configuration.Flags.HasFlag(NpcConfiguration.Flag.Female)) continue;

                        markedForDelete.Add(entry);
                    }

                    // If the deletion would empty the leveled list, do nothing.
                    if (markedForDelete.Count > 0 && markedForDelete.Count != entryCount)
                    {
                        foreach (var obj in markedForDelete)
                            if (obj is not null) lvln.Entries.Remove(obj);

                        Console.WriteLine("Removed male entries in leveled list " + lvln.EditorID + ".");
                    }

                    // If the leveled list was modified, add it to the patch file.
                    if(wasModified || lvln.Entries.Count != entryCount)
                        state.PatchMod.LeveledNpcs.Set(lvln);
                }
            }
        }
    }
}
